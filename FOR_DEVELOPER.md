# 📚 SmartSync Adaptive — Полное руководство разработчика

> Этот документ описывает всё, что нужно знать о системе: как она работает, почему так спроектирована, и как её развивать.

---

## Оглавление

1. [Общий обзор](#1-общий-обзор)
2. [Как работает приём данных](#2-как-работает-приём-данных)
3. [Валидация контейнеров](#3-валидация-контейнеров)
4. [Расчёт уверенности (Confidence)](#4-расчёт-уверенности-confidence)
5. [Справочники и словари](#5-справочники-и-словари)
6. [База данных](#6-база-данных)
7. [Frontend](#7-frontend)
8. [Интеграция с 1С](#8-интеграция-с-1с)
9. [Деплой и продакшн](#9-деплой-и-продакшн)
10. [Расширение системы](#10-расширение-системы)

---

## 1. Общий обзор

### Что делает система?

SmartSync Adaptive решает одну главную проблему: **превращает хаотичные данные о контейнерах в структурированную информацию**.

```
ВХОД (что присылают операторы):          ВЫХОД (что получаем):
────────────────────────────────────────────────────────────────
"Контейнер MSKU1234560 на            →   {
станции Гончарово, 1857 км                 containerNumber: "MSKU1234560",
до Иня-Восточная"                          statusCode: "ON_RAIL",
                                           location: "Гончарово",
                                           distanceToDestinationKm: 1857,
                                           confidence: 1.0
                                         }
```

### Ключевые принципы

1. **Не требуем от операторов менять формат** — система адаптируется под них
2. **Высокая точность** — 95%+ уверенность благодаря ISO 6346 и справочникам
3. **Прозрачность** — всегда видно откуда данные и как обработаны
4. **Расширяемость** — легко добавлять новые форматы и источники

---

## 2. Как работает приём данных

### Поток обработки

```
┌──────────────────────────────────────────────────────────────┐
│                         INPUT                                 │
│  Текст / JSON / CSV / Массив — любой формат                  │
└───────────────────────────────┬──────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────┐
│                    FORMAT DETECTOR                            │
│                                                               │
│  1. Это массив? → TABLE_ROWS                                 │
│  2. Это JSON строка? → JSON_OBJECT или JSON_ARRAY            │
│  3. Есть разделители (;,|)? → CSV_TEXT                       │
│  4. Иначе → PLAIN_TEXT                                       │
│                                                               │
│  Результат: { type: "PLAIN_TEXT", confidence: 0.9 }          │
└───────────────────────────────┬──────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────┐
│                    UNIVERSAL PARSER                           │
│                                                               │
│  Для текста:                                                 │
│  - Ищем номера контейнеров (regex)                           │
│  - Ищем локации (паттерны "ст.", "порт")                     │
│  - Ищем расстояние (\d+ км)                                  │
│  - Ищем даты (DD.MM.YYYY)                                    │
│  - Определяем статус по ключевым словам                      │
│                                                               │
│  Для JSON/CSV:                                               │
│  - Маппим поля по названиям                                  │
│  - Ищем синонимы (container, containerNumber, номер и т.д.)  │
│                                                               │
│  Результат: ParsedItem[]                                     │
└───────────────────────────────┬──────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────┐
│                    DATA VALIDATOR                             │
│                                                               │
│  Для каждого ParsedItem:                                     │
│                                                               │
│  1. КОНТЕЙНЕР (главное):                                     │
│     - Проверка формата 4 буквы + 7 цифр                      │
│     - Расчёт контрольной цифры по ISO 6346                   │
│     - Проверка в базе BIC-кодов (известные владельцы)        │
│     - Автоисправление опечаток                               │
│                                                               │
│  2. ЛОКАЦИЯ:                                                 │
│     - Поиск в справочнике станций/портов                     │
│     - Определение типа (STATION, PORT, WAREHOUSE)            │
│     - Нормализация названия                                  │
│                                                               │
│  3. СТАТУС:                                                  │
│     - Маппинг на известные коды                              │
│     - Проверка консистентности со типом локации              │
│                                                               │
│  4. РАСЧЁТ CONFIDENCE                                        │
│                                                               │
│  Результат: ValidationResult                                 │
└───────────────────────────────┬──────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────┐
│                       DATABASE                                │
│                                                               │
│  - Создаём/находим Container                                 │
│  - Создаём StatusEvent                                       │
│  - Сохраняем RawMessage (для аудита)                         │
└──────────────────────────────────────────────────────────────┘
```

### Ключевые файлы

| Файл | Что делает |
|------|------------|
| `middleware/inputProcessor.ts` | Оркестратор, координирует всё |
| `middleware/formatDetector.ts` | Определяет формат входных данных |
| `middleware/universalParser.ts` | Извлекает данные из любого формата |
| `middleware/dataValidator.ts` | Валидирует и считает confidence |
| `middleware/containerValidator.ts` | ISO 6346 валидация |
| `middleware/locationDictionary.ts` | Справочник локаций |

---

## 3. Валидация контейнеров

### Стандарт ISO 6346

Каждый контейнер имеет уникальный номер по международному стандарту:

```
    M  S  C  U  1  2  3  4  5  6  0
    ▲  ▲  ▲  ▲  ▲──────────────▲  ▲
    │  │  │  │  │              │  │
    │  │  │  │  │              │  └── Контрольная цифра
    │  │  │  │  └──────────────┴───── Серийный номер (6 цифр)
    │  │  │  └───────────────────────  Код категории (U/J/Z)
    └──┴──┴──────────────────────────  Код владельца (3 буквы)
```

### Алгоритм расчёта контрольной цифры

```javascript
// Таблица значений ISO 6346
const values = {
  'A': 10, 'B': 12, 'C': 13, 'D': 14, 'E': 15, 'F': 16, 'G': 17,
  'H': 18, 'I': 19, 'J': 20, 'K': 21, 'L': 23, 'M': 24, 'N': 25,
  'O': 26, 'P': 27, 'Q': 28, 'R': 29, 'S': 30, 'T': 31, 'U': 32,
  'V': 34, 'W': 35, 'X': 36, 'Y': 37, 'Z': 38,
  '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,
  '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
};

function calculateCheckDigit(code) {
  // code = первые 10 символов (MSCU123456)
  let sum = 0;
  for (let i = 0; i < 10; i++) {
    sum += values[code[i]] * Math.pow(2, i);
  }
  const remainder = sum % 11;
  return remainder === 10 ? '0' : String(remainder);
}

// Пример: MSCU123456
// M=24, S=30, C=13, U=32, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6
// sum = 24*1 + 30*2 + 13*4 + 32*8 + 1*16 + 2*32 + 3*64 + 4*128 + 5*256 + 6*512
//     = 24 + 60 + 52 + 256 + 16 + 64 + 192 + 512 + 1280 + 3072 = 5528
// 5528 % 11 = 5528 - 502*11 = 5528 - 5522 = 6
// Контрольная цифра = 6
// Полный номер: MSCU1234566
```

### Автоисправление опечаток

Система автоматически исправляет частые опечатки:

| Ввод | Исправлено | Причина |
|------|------------|---------|
| `MSC0123456` | `MSCO123456` | `0` в буквенной части → `O` |
| `HL8U1234567` | `HLBU1234567` | `8` в буквенной части → `B` |
| `00LU7654321` | `OOLU7654321` | `00` в начале → `OO` |
| `MSKU123456O` | `MSKU1234560` | `O` в цифровой части → `0` |

---

## 4. Расчёт уверенности (Confidence)

### Формула

```
БАЗОВАЯ УВЕРЕННОСТЬ (от валидации контейнера):
├── Формат XXXX0000000 OK:          85%
├── + Контрольная цифра верна:      +10%
├── + Известный владелец (BIC):     +5%
└── + Без автоисправлений:          +2%
                                    ────
                          Максимум: 102% → cap to 100%

БОНУСЫ (за дополнительные данные):
├── Известный статус:               +5%
├── Локация из справочника:         +5%
├── Полнота данных > 50%:           +3%
└── Логическая консистентность:     +2%

ШТРАФЫ:
├── Есть критические ошибки:        ×0.5
└── Много предупреждений (>3):      ×0.95
```

### Примеры

**Идеальный случай (100%):**
```
Вход: "MSCU1234560 на станции Гончарово"

Контейнер:
  ✓ Формат OK                     85%
  ✓ Контрольная цифра верна      +10%  = 95%
  ✓ MSCU - известный владелец    + 5%  = 100%
  ✓ Без исправлений              + 2%  = 102% → 100%

Бонусы:
  ✓ Статус ON_RAIL определён     + 5%
  ✓ Гончарово в справочнике      + 5%
                                  ────
                          Итого: 100% (cap)
```

**С опечаткой (92%):**
```
Вход: "MSC01234560 доставлен"

Контейнер:
  ✓ Формат OK (после исправления) 85%
  ✗ Контрольная цифра не совпала +0%   = 85%
  ✓ MSCO - похож на MSC*         +5%   = 90%
  ✗ Были исправления             +0%   = 90%

Бонусы:
  ✓ Статус DELIVERED             +5%   = 95%
  
Штрафы:
  ⚠ 2 предупреждения             -3%   = 92%
```

---

## 5. Справочники и словари

### Справочник локаций (`locationDictionary.ts`)

**Структура:**
```typescript
interface KnownLocation {
  name: string;           // Каноническое название
  type: LocationType;     // STATION, PORT, WAREHOUSE, CUSTOMS, CITY
  aliases: string[];      // Варианты написания
  region?: string;        // Регион
  country: string;        // Страна (ISO 2)
}
```

**Категории:**

| Категория | Примеры | Количество |
|-----------|---------|------------|
| ЖД станции РФ | Гончарово, Забайкальск, Новосибирск | 20+ |
| Порты Китая | Шанхай, Циндао, Нинбо, Далянь | 10+ |
| Порты РФ | Владивосток, Восточный, Находка | 5+ |
| Прочие порты | Пусан, Сингапур, Роттердам | 10+ |
| СВХ | Шереметьево, Домодедово | 5+ |

### Словарь статусов (`universalParser.ts`)

```typescript
const statusMap = [
  { keywords: ['доставлен', 'delivered'], code: 'DELIVERED' },
  { keywords: ['в порту', 'in port'], code: 'IN_PORT' },
  { keywords: ['прибыл в порт', 'arrived port'], code: 'ARRIVED_PORT' },
  { keywords: ['на станции', 'ст.'], code: 'ON_RAIL' },
  { keywords: ['в море', 'on ship', 'морем'], code: 'ON_SHIP' },
  { keywords: ['на складе', 'warehouse', 'свх'], code: 'ON_WAREHOUSE' },
  { keywords: ['таможн', 'customs'], code: 'CUSTOMS' },
  { keywords: ['растаможен'], code: 'CUSTOMS_CLEARED' },
  // ... ещё 10+ статусов
];
```

### Правила консистентности

```typescript
const STATUS_LOCATION_RULES = {
  'ON_RAIL': ['STATION'],        // На ЖД → станция
  'IN_PORT': ['PORT'],           // В порту → порт
  'ON_WAREHOUSE': ['WAREHOUSE'], // На складе → склад
  'DELIVERED': ['CITY', 'WAREHOUSE'],
};
```

Если статус `ON_RAIL`, а локация — порт, система выдаёт предупреждение и снижает `consistencyScore`.

---

## 6. База данных

### Модель данных (Prisma)

```
┌─────────────┐       ┌──────────────┐       ┌─────────────┐
│   Carrier   │       │  Container   │       │   Client    │
├─────────────┤       ├──────────────┤       ├─────────────┤
│ id          │◄──┐   │ id           │   ┌──►│ id          │
│ name        │   │   │ containerNum │   │   │ name        │
│ type        │   │   │ type         │   │   │ code        │
│ code        │   │   │ origin       │   │   │ email       │
└─────────────┘   │   │ destination  │   │   └─────────────┘
                  │   │ clientId     │───┘
                  │   │ carrierId    │───┘
                  │   └──────┬───────┘
                  │          │ 1:N
                  │          ▼
                  │   ┌──────────────┐       ┌─────────────┐
                  │   │ StatusEvent  │       │ RawMessage  │
                  │   ├──────────────┤       ├─────────────┤
                  │   │ id           │       │ id          │
                  │   │ containerId  │       │ sourceType  │
                  │   │ statusCode   │       │ content     │
                  │   │ location     │   ┌──►│ processed   │
                  │   │ distance     │   │   │ errorMsg    │
                  │   │ eta          │   │   └─────────────┘
                  │   │ eventTime    │   │
                  │   │ sourceType   │   │
                  │   │ rawMessageId │───┘
                  │   └──────────────┘
                  │
                  └─── Foreign Keys
```

### Индексы

```sql
-- Для быстрого поиска по номеру контейнера
CREATE UNIQUE INDEX container_number_idx ON "Container"("containerNumber");

-- Для запросов истории
CREATE INDEX status_event_container_idx ON "StatusEvent"("containerId");
CREATE INDEX status_event_time_idx ON "StatusEvent"("eventTime" DESC);
```

---

## 7. Frontend

### Страницы

| Путь | Компонент | Описание |
|------|-----------|----------|
| `/dashboard` | `DashboardPage` | Обзор: метрики, алерты |
| `/containers` | `ContainersPage` | Таблица контейнеров |
| `/containers/:id` | `ContainerDetailsPage` | Детали + история |
| `/ingest` | `IngestPage` | Загрузка данных |

### Ключевые технологии

- **React 18** — UI библиотека
- **React Query** — кэширование и синхронизация с сервером
- **React Router 6** — маршрутизация
- **TailwindCSS** — стилизация
- **Lucide Icons** — иконки

### Структура компонентов

```
frontend/src/
├── pages/
│   ├── DashboardPage.tsx      # Дашборд
│   ├── ContainersPage.tsx     # Список контейнеров
│   ├── ContainerDetailsPage.tsx # Детали
│   └── IngestPage.tsx         # Загрузка данных
├── components/
│   ├── Layout.tsx             # Общий layout
│   ├── StatusBadge.tsx        # Бейдж статуса
│   ├── LoadingSpinner.tsx     # Индикатор загрузки
│   ├── EmptyState.tsx         # Пустое состояние
│   └── TimeAgo.tsx            # "5 минут назад"
├── api/
│   └── client.ts              # Axios клиент
└── types/
    └── index.ts               # TypeScript типы
```

---

## 8. Интеграция с 1С

### Экспорт данных

**Endpoint:** `GET /api/export/1c?format=csv|json`

**Структура CSV (соответствует таблице 1С):**

| Колонка 1С | Поле в API |
|------------|------------|
| Номер КТК | container.containerNumber |
| Тип КТК | container.containerType |
| Состояние | statusText |
| Пункт отправления | container.originPoint |
| Пункт назначения | container.destinationPoint |
| Текущее местоположение | location |
| Расстояние до назначения | distanceToDestinationKm |
| Ориентировочная дата прибытия | eta |

### Будущая интеграция (HTTP-сервис)

В 1С можно создать HTTP-сервис который будет:
1. Вызываться по расписанию (каждые 15 минут)
2. Запрашивать `/api/export/1c?format=json`
3. Обновлять записи в регистре сведений

---

## 9. Деплой и продакшн

### Docker Compose

```bash
# Сборка и запуск
docker-compose up -d --build

# Логи
docker-compose logs -f backend

# Остановка
docker-compose down
```

### Environment Variables

```env
# Database
DATABASE_URL=postgresql://user:pass@host:5432/db

# Server
PORT=3001
NODE_ENV=production
CORS_ORIGIN=https://app.railtrust.ru

# Logging
LOG_LEVEL=info
```

### Health Checks

```bash
# Backend
curl http://localhost:3001/api/health

# Response
{
  "status": "ok",
  "database": "connected",
  "timestamp": "2025-12-01T10:00:00.000Z"
}
```

---

## 10. Расширение системы

### Добавление нового формата данных

1. Обновить `FormatDetector`:
```typescript
// formatDetector.ts
if (looksLikeNewFormat(content)) {
  return { type: 'NEW_FORMAT', confidence: 0.8 };
}
```

2. Добавить парсер в `UniversalParser`:
```typescript
// universalParser.ts
private parseNewFormat(content: NewFormatType): ParsedItem[] {
  // Логика парсинга
}
```

### Добавление нового статуса

1. Обновить Prisma enum:
```prisma
enum StatusCode {
  // ...existing
  NEW_STATUS
}
```

2. Добавить в словарь:
```typescript
// universalParser.ts
{ keywords: ['новый статус', 'new status'], code: 'NEW_STATUS' }
```

3. Запустить миграцию:
```bash
npm run prisma:migrate
```

### Добавление новой локации

```typescript
// locationDictionary.ts
const RUSSIAN_STATIONS: KnownLocation[] = [
  // ...existing
  { 
    name: 'Новая Станция', 
    type: 'STATION', 
    aliases: ['новая станция', 'new station'],
    region: 'Регион',
    country: 'RU'
  },
];
```

### Интеграция LLM для сложных текстов

В коде оставлены комментарии `// TODO: LLM Integration Point`:

```typescript
// universalParser.ts
async parseText(text: string): Promise<ParsedItem[]> {
  // Сначала пробуем regex
  const items = this.parseTextWithRegex(text);
  
  // TODO: LLM Integration Point
  // Если regex не нашёл данные, можно вызвать LLM:
  // if (items.length === 0 && process.env.OPENAI_API_KEY) {
  //   items = await this.parseTextWithLLM(text);
  // }
  
  return items;
}
```

---

## 📞 Поддержка

**Разработка:** SmartSync Team  
**Email:** dev@railtrust.ru  
**Версия:** 1.0.0  
**Дата документа:** Декабрь 2025

